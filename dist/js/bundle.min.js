class SimpleGameEngine{constructor(t){this.container=document.querySelector(t.container)||document.body,this.width=t.width||800,this.height=t.height||600,this.gameObjects=[],this.collisionPairs=[],this.eventListeners={},this.container.style.position="relative",this.container.style.width=`${this.width}px`,this.container.style.height=`${this.height}px`,this.container.style.overflow="hidden",this.lastTime=0,this.start()}createGameObject(t,e={}){let i=document.getElementById(t)||document.querySelector(`.${t}`);i||(i=document.createElement("div"),i.id=t,i.style.backgroundColor=e.backgroundColor||"red",this.container.appendChild(i)),i.style.position="absolute",i.style.left=`${e.x+"px"||i.style.left}`,i.style.top=`${e.y+"px"||i.style.top}`,i.style.height=`${e.height+"px"||i.style.height}`,i.style.width=`${e.width+"px"||i.style.width}`;const s={id:t,element:i,x:e.x||0,y:e.y||0,width:e.width||i.offsetWidth,height:e.height||i.offsetHeight,velocityX:0,velocityY:0,autoMove:e.autoMove||null,isStatic:e.isStatic||!1,isPlayerControlled:e.isPlayerControlled||!1,requireGround:e.requireGround||!1,tag:e.tag||"",onCollision:e.onCollision||null};return this.gameObjects.push(s),s.isPlayerControlled&&setTimeout(()=>{this.emit("playerCreated",s)},100),s}start(){const t=e=>{const i=e-this.lastTime;this.lastTime=e,this.update(i),this.checkCollisions(),requestAnimationFrame(t)};requestAnimationFrame(t)}update(t){this.gameObjects.forEach(e=>{e.isStatic||(e.autoMove&&(e.velocityX=e.autoMove.x,e.velocityY=e.autoMove.y),e.requireGround&&!this.isOnGround(e)&&(e.velocityY+=t/500*500),e.x+=e.velocityX*(t/1e3),e.y+=e.velocityY*(t/1e3),this.emit("hitBoundary",e),e.element.style.left=`${e.x}px`,e.element.style.top=`${e.y}px`)})}isOnGround(t){const e={x:t.x,y:t.y+t.height+1,width:t.width,height:1};return this.gameObjects.some(i=>i!==t&&!i.isPlatform&&this.isColliding(e,i))}checkCollisions(){for(let t=0;t<this.gameObjects.length;t++)for(let e=t+1;e<this.gameObjects.length;e++){const i=this.gameObjects[t],s=this.gameObjects[e];if(this.isColliding(i,s)){const t=this.getCollisionData(i,s);this.resolveCollision(i,s,t),i.onCollision&&i.onCollision(s,t),s.onCollision&&s.onCollision(i,t),this.emit("collision",{obj1:i,obj2:s,...t})}}}getCollisionData(t,e){const i=Math.min(t.x+t.width-e.x,e.x+e.width-t.x),s=Math.min(t.y+t.height-e.y,e.y+e.height-t.y);let o;return o=i<s?t.x<e.x?"left":"right":t.y<e.y?"top":"bottom",{overlapX:i,overlapY:s,direction:o}}resolveCollision(t,e,{direction:i,overlapX:s,overlapY:o}){t.isStatic&&e.isStatic||("left"===i?(t.isStatic||(t.x-=s),e.isStatic||(e.x+=s)):"right"===i?(t.isStatic||(t.x+=s),e.isStatic||(e.x-=s)):"top"===i?(t.isStatic||(t.y-=o),e.isStatic||(e.y+=o)):"bottom"===i&&(t.isStatic||(t.y+=o),e.isStatic||(e.y-=o)),t.element.style.left=`${t.x}px`,t.element.style.top=`${t.y}px`,e.element.style.left=`${e.x}px`,e.element.style.top=`${e.y}px`,"left"===i||"right"===i?(t.isStatic||(t.velocityX=0),e.isStatic||(e.velocityX=0)):(t.isStatic||(t.velocityY=0),e.isStatic||(e.velocityY=0)))}isColliding(t,e){return t.x<e.x+e.width&&t.x+t.width>e.x&&t.y<e.y+e.height&&t.y+t.height>e.y}on(t,e){this.eventListeners[t]||(this.eventListeners[t]=[]),this.eventListeners[t].push(e)}emit(t,e){const i=this.eventListeners[t];i&&i.forEach(t=>t(e))}}